<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SlenderHunt: HD</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        body { background: #0a0a0a; color: #eee; font-family: 'Courier New', monospace; overflow: hidden; display: flex; flex-direction: column; height: 100vh; width: 100vw; }
        
        #ui-bar { height: 40px; width: 100%; display: flex; justify-content: space-around; align-items: center; background: #111; font-size: 11px; color: #f1c40f; flex-shrink: 0; border-bottom: 2px solid #333; position: relative; z-index: 10; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #ui-bar span { font-weight: bold; color: #fff; }

        #game-area { flex: 1; display: flex; align-items: center; justify-content: center; padding: 5px; min-height: 0; background: radial-gradient(circle, #1a1a1a 0%, #000 100%); }
        #canvas-container { position: relative; box-shadow: 0 0 20px rgba(0,0,0,1); }
        canvas { background: #244120; display: block; border: 4px solid #444; max-height: 45vh; max-width: 95vw; object-fit: contain; image-rendering: pixelated; }
        
        #control-panel { padding: 5px 0 40px 0; background: #000; width: 100%; display: flex; flex-direction: column; align-items: center; flex-shrink: 0; border-top: 1px solid #222; }
        .dpad { display: grid; grid-template-columns: repeat(3, 75px); grid-template-rows: repeat(3, 62px); grid-gap: 12px; }
        .btn { background: linear-gradient(to bottom, #34495e, #2c3e50); border-radius: 12px; display: flex; align-items: center; justify-content: center; user-select: none; border-bottom: 5px solid #1a252f; cursor: pointer; font-weight: bold; color: white; font-size: 13px; text-shadow: 1px 1px #000; }
        .btn:active { border-bottom: 0; transform: translateY(4px); background: #2c3e50; }
        #bomb-btn { background: linear-gradient(to bottom, #e74c3c, #c0392b); border-bottom-color: #962d22; }
        #dash-btn { background: linear-gradient(to bottom, #9b59b6, #8e44ad); border-bottom-color: #6c3483; }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 9999; display: flex; flex-direction: column; align-items: center; padding: 20px; text-align: center; overflow-y: auto; }
        .card { background: #1a1a1a; padding: 12px; margin: 8px; border-radius: 10px; width: 100%; max-width: 340px; border: 2px solid #333; cursor: pointer; display: flex; align-items: center; }
        .portrait { width: 55px; height: 55px; border-radius: 5px; margin-right: 15px; flex-shrink: 0; border: 2px solid #555; display: flex; align-items: center; justify-content: center; font-size: 20px; box-shadow: inset 0 0 10px #000; }
        .hidden { display: none !important; }
        .story-text { color: #f1c40f; font-style: italic; margin: 15px 0; font-size: 12px; max-width: 320px; line-height: 1.5; }
    </style>
</head>
<body>

<div id="ui-bar">
    <div>DEPTH: <span id="stage-txt">1</span>/10</div>
    <div>HP: <span id="hp-txt">0</span></div>
    <div>GOLD: $<span id="gold-txt">0</span></div>
</div>

<div id="intro-screen" class="overlay">
    <h1 style="color:#e74c3c; margin-bottom: 5px; letter-spacing: 4px;">SLENDERHUNT</h1>
    <p class="story-text">"The suburbs are no longer ours. Reality has pixelated into a lethal grid. You are the last Cleaner. Reach Depth 10. Purge the Singularity."</p>
    
    <div class="card" onclick="setupGame('Vance', 5, 2, true, false, false, '#3498db')">
        <div class="portrait" style="background:#3498db">ðŸª–</div>
        <div class="card-info"><b>VANCE: VETERAN</b><p style="font-size: 9px; color:#aaa;">Hydraulic Kicking | HP: 5</p></div>
    </div>
    <div class="card" onclick="setupGame('Kaito', 3, 3, false, true, true, '#2ecc71')">
        <div class="portrait" style="background:#2ecc71">ðŸŽ­</div>
        <div class="card-info"><b>KAITO: EXILE</b><p style="font-size: 9px; color:#aaa;">Matter Phasing | HP: 3</p></div>
    </div>
    <div class="card" onclick="setupGame('Grom', 10, 5, false, false, true, '#e67e22')">
        <div class="portrait" style="background:#e67e22">ðŸŒ‹</div>
        <div class="card-info"><b>GROM: AUGMENT</b><p style="font-size: 9px; color:#aaa;">Massive Blast | HP: 10</p></div>
    </div>
</div>

<div id="death-screen" class="overlay hidden" style="justify-content: center;">
    <h1 style="color:#e74c3c;">SIGNAL LOST</h1>
    <div class="card" onclick="location.reload()" style="background:#e74c3c; color:white; justify-content:center; border:none;"><b>RECONNECT</b></div>
</div>

<div id="shop-screen" class="overlay hidden" style="justify-content: center;">
    <h2 style="color:#f1c40f;">SECTOR PURIFIED</h2>
    <p id="lore-body" class="story-text"></p>
    <div class="card" onclick="buy('hp')"><b>REPAIR NANO-BOTS ($100)</b></div>
    <div class="card" onclick="buy('range')"><b>EXPLOSIVE OVERCLOCK ($75)</b></div>
    <div class="card" onclick="nextStage()" style="background:#27ae60; color:white; justify-content:center;"><b>DESCEND FURTHER</b></div>
</div>

<div id="game-area">
    <div id="canvas-container"><canvas id="gameCanvas"></canvas></div>
</div>

<div id="control-panel">
    <div class="dpad">
        <div class="btn" id="dash-btn">DASH</div><div class="btn" id="ctrl-up">UP</div><div></div>
        <div class="btn" id="ctrl-left">LEFT</div><div class="btn" id="bomb-btn">BOMB</div><div class="btn" id="ctrl-right">RIGHT</div>
        <div></div><div class="btn" id="ctrl-down">DOWN</div><div></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const TILE = 40, ROWS = 11, COLS = 11;
    canvas.width = COLS * TILE; canvas.height = ROWS * TILE;

    let grid = [], bombs = [], enemies = [], explosions = [], gold = 0;
    let player = { x: 1, y: 1, hp: 0, range: 2, invuln: 0, color: '#fff', lastMove: 0 };
    let stage = 1, active = false, frame = 0, audioCtx = null, shake = 0, moveDir = {dx:0, dy:0};

    const LORE = ["","The static is screaming.","The grid is shifting.","Logic is failing.","BOSS DETECTED.","Entrance to the Void.","Flesh becomes data.","The walls have eyes.","Heartbeat flatlining.","THE SINGULARITY."];

    function initAudio() { if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    function sfx(freq, type, dur, vol=0.05) {
        if(!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + dur);
    }

    function setupGame(name, hp, range, kick, phase, remote, color) {
        initAudio();
        Object.assign(player, { name, hp, range, canKick: kick, canPhase: phase, remote: remote, color, x:1, y:1, lastMove: 0 });
        document.getElementById('intro-screen').classList.add('hidden');
        buildLevel(); active = true;
    }

    function buildLevel() {
        grid = []; bombs = []; enemies = []; explosions = [];
        const isBoss = (stage === 5 || stage === 10);
        for (let r = 0; r < ROWS; r++) {
            grid[r] = [];
            for (let c = 0; c < COLS; c++) {
                if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1 || (r % 2 === 0 && c % 2 === 0)) grid[r][c] = 1;
                else grid[r][c] = (Math.random() < 0.35 && !(r < 3 && c < 3)) ? 2 : 0;
            }
        }
        if (isBoss) enemies.push({ x: 9, y: 9, dx: -1, dy: 0, t: 0, speed: (stage === 10 ? 10 : 15), hp: (stage === 10 ? 60 : 25), isBoss: true, trait: 'boss' });
        else {
            let bricks = [];
            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) if(grid[r][c]===2) bricks.push({r,c});
            if(bricks.length) grid[bricks[0].r][bricks[0].c] = 4;
            for(let i=0; i < stage + 1; i++) {
                let rx, ry; do { rx = Math.floor(Math.random() * COLS); ry = Math.floor(Math.random() * ROWS); } while(grid[ry][rx] !== 0 || (rx < 4 && ry < 4));
                let trait = (stage >= 3 && Math.random() > 0.6) ? 'sprinter' : (stage >= 6 && Math.random() > 0.7 ? 'ghost' : 'grunt');
                enemies.push({ x: rx, y: ry, dx: 1, dy: 0, t: 0, speed: (trait==='sprinter'?20:40), hp: 1, trait });
            }
        }
    }

    function drawTacticalHuman(x, y, color, frame, invuln, isEnemy, isBoss, hp, trait) {
        if (invuln % 6 < 3 && invuln > 0) return;
        const cx = x * TILE + TILE/2, cy = y * TILE + TILE/2;
        const walk = Math.sin(frame * 0.25) * 4;
        const sm = isBoss ? 1.6 : 1;
        
        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.ellipse(cx, cy+15*sm, 10*sm, 5*sm, 0, 0, 7); ctx.fill();

        // Legs (Fluid)
        ctx.fillStyle = "#111";
        ctx.fillRect(cx-6*sm, cy+(6*sm)+walk, 5*sm, 8*sm); // L
        ctx.fillRect(cx+1*sm, cy+(6*sm)-walk, 5*sm, 8*sm); // R

        // Body + Tactical Vest
        let c = isEnemy ? (trait==='sprinter'?'#ff4d4d':(trait==='ghost'?'#a040ff':'#444')) : color;
        if(isBoss) c = "#111";
        ctx.fillStyle = c;
        ctx.fillRect(cx-9*sm, cy-5*sm, 18*sm, 14*sm); 
        ctx.fillStyle = "rgba(0,0,0,0.3)"; // Vest detail
        ctx.fillRect(cx-9*sm, cy+1*sm, 18*sm, 3*sm);
        ctx.fillRect(cx-2*sm, cy-5*sm, 4*sm, 14*sm);

        // Head
        ctx.fillStyle = "#FFDBAC";
        ctx.fillRect(cx-6*sm, cy-16*sm, 12*sm, 11*sm);

        // Visor (Glow)
        ctx.fillStyle = isEnemy ? "#f00" : "#0ff";
        if(trait==='ghost') ctx.fillStyle = "#ff00ff";
        ctx.fillRect(cx-7*sm, cy-15*sm, 14*sm, 5*sm);
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fillRect(cx-5*sm, cy-15*sm, 2*sm, 2*sm); // Reflection

        // Boss Health Bar
        if(isBoss) { 
            ctx.fillStyle = "#222"; ctx.fillRect(x*TILE, y*TILE-12, TILE, 6);
            ctx.fillStyle = "#f00"; ctx.fillRect(x*TILE, y*TILE-12, (hp/(stage===10?60:25))*TILE, 6); 
        }
    }

    function drawBricks(x, y, isDoor) {
        const px = x * TILE, py = y * TILE;
        if(isDoor) {
            ctx.fillStyle = "#000"; ctx.fillRect(px, py, TILE, TILE);
            ctx.strokeStyle = "#0f0"; ctx.lineWidth = 2;
            ctx.strokeRect(px+5, py+5, TILE-10, TILE-10);
            return;
        }
        // Detailed Brick Pattern
        ctx.fillStyle = (stage > 5) ? "#2c2c2c" : "#7a3420";
        ctx.fillRect(px, py, TILE, TILE);
        ctx.strokeStyle = (stage > 5) ? "#111" : "#5a2510";
        ctx.lineWidth = 1;
        // Rows
        ctx.strokeRect(px+1, py+1, TILE-2, TILE/2-2);
        ctx.strokeRect(px+1, py+TILE/2+1, TILE-2, TILE/2-2);
        // Vertical staggers
        ctx.beginPath();
        ctx.moveTo(px+TILE/2, py); ctx.lineTo(px+TILE/2, py+TILE/2);
        ctx.moveTo(px+TILE/4, py+TILE/2); ctx.lineTo(px+TILE/4, py+TILE);
        ctx.moveTo(px+3*TILE/4, py+TILE/2); ctx.lineTo(px+3*TILE/4, py+TILE);
        ctx.stroke();
        // Highlights
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(px+2, py+2, TILE-4, 2);
    }

    function handleDash() {
        if(!active || gold < 10 || (moveDir.dx === 0 && moveDir.dy === 0)) return;
        let nx = player.x + (moveDir.dx * 2), ny = player.y + (moveDir.dy * 2);
        if(grid[ny] && grid[ny][nx] !== 1) {
            if(grid[ny][nx] !== 0 && !player.canPhase) return;
            gold -= 10; player.x = nx; player.y = ny;
            shake = 6; sfx(600, 'sine', 0.1);
            explosions.push({ x: player.x - moveDir.dx, y: player.y - moveDir.dy, life: 6, dashTrail: true });
        }
    }

    function handleInput() {
        if(!active || (moveDir.dx === 0 && moveDir.dy === 0)) return;
        let now = Date.now();
        if(now - player.lastMove < 150) return;
        let nx = player.x + moveDir.dx, ny = player.y + moveDir.dy;
        let bAt = bombs.find(b => b.x === nx && b.y === ny);
        if(bAt && player.canKick) {
            sfx(200, 'sine', 0.1);
            let kx = moveDir.dx, ky = moveDir.dy;
            let si = setInterval(() => {
                let bx = bAt.x + kx, by = bAt.y + ky;
                let hitE = enemies.find(e => e.x === bx && e.y === by);
                if(grid[by] && grid[by][bx] === 0 && !bombs.find(ob => ob.x === bx && ob.y === by) && !hitE) { bAt.x = bx; bAt.y = by; }
                else clearInterval(si);
            }, 80);
            player.lastMove = now; return;
        }
        if(!grid[ny] || grid[ny][nx] === 1 || bAt) return;
        if((grid[ny][nx] === 2 || grid[ny][nx] === 4) && !player.canPhase) return;
        player.x = nx; player.y = ny; player.lastMove = now;
        if(grid[ny][nx] === 3 && enemies.length === 0) {
            active = false;
            if(stage === 10) { alert("SINGULARITY PURGED."); location.reload(); return; }
            document.getElementById('lore-body').innerText = LORE[stage];
            document.getElementById('shop-screen').classList.remove('hidden');
            document.getElementById('shop-gold').innerText = gold;
        }
    }

    const binds = {'ctrl-up': {dx:0, dy:-1}, 'ctrl-down': {dx:0, dy:1}, 'ctrl-left': {dx:-1, dy:0}, 'ctrl-right': {dx:1, dy:0}};
    Object.keys(binds).forEach(id => {
        const el = document.getElementById(id);
        const start = (e) => { e.preventDefault(); moveDir = binds[id]; };
        const end = (e) => { e.preventDefault(); moveDir = {dx:0, dy:0}; };
        el.addEventListener('touchstart', start); el.addEventListener('touchend', end);
        el.addEventListener('mousedown', start); el.addEventListener('mouseup', end);
    });
    document.getElementById('bomb-btn').addEventListener('touchstart', (e) => { e.preventDefault(); handleBombAction(); });
    document.getElementById('dash-btn').addEventListener('touchstart', (e) => { e.preventDefault(); handleDash(); });

    function handleBombAction() {
        if(!active || bombs.length >= 3) return;
        if(player.remote && bombs.length > 0) {
            shake = 12; while(bombs.length > 0) { let b = bombs.shift(); explode(b.x, b.y); }
        } else {
            if(!bombs.find(b => b.x === player.x && b.y === player.y)) {
                bombs.push({ x: player.x, y: player.y, timer: player.remote ? 9999 : 100 });
                sfx(100, 'square', 0.1);
            }
        }
    }

    function explode(bx, by) {
        sfx(60, 'sawtooth', 0.5, 0.2); shake = 10;
        [[0,0],[0,1],[0,-1],[1,0],[-1,0]].forEach(d => {
            for(let i=0; i <= player.range; i++) {
                let ex = bx + d[0] * i, ey = by + d[1] * i;
                if(!grid[ey] || grid[ey][ex] === 1) break;
                explosions.push({ x: ex, y: ey, life: 15 });
                if(grid[ey][ex] === 2 || grid[ey][ex] === 4) { gold += 15; grid[ey][ex] = (grid[ey][ex] === 4) ? 3 : 0; break; }
                enemies.forEach((e, idx) => {
                    if (e.x === ex && e.y === ey) { e.hp--; if (e.hp <= 0) { if (e.isBoss) grid[e.y][e.x] = 3; enemies.splice(idx, 1); gold += 50; } }
                });
                if(player.x === ex && player.y === ey && player.invuln <= 0) { player.hp--; player.invuln = 60; sfx(40, 'sine', 0.8); }
            }
        });
    }

    function buy(item) {
        if (item === 'hp' && gold >= 100) { gold -= 100; player.hp++; sfx(800, 'sine', 0.2); }
        if (item === 'range' && gold >= 75) { gold -= 75; player.range++; sfx(800, 'sine', 0.2); }
        document.getElementById('shop-gold').innerText = gold;
    }

    function nextStage() { stage++; document.getElementById('shop-screen').classList.add('hidden'); buildLevel(); active = true; }

    function loop() {
        handleInput();
        let sx = 0, sy = 0;
        if(shake > 0) { sx = (Math.random()-0.5)*shake; sy = (Math.random()-0.5)*shake; shake *= 0.85; }
        ctx.setTransform(1,0,0,1,sx,sy);
        
        // Floor Texture
        ctx.fillStyle = (stage > 5) ? '#111' : '#1e381b';
        ctx.fillRect(-TILE, -TILE, canvas.width+TILE*2, canvas.height+TILE*2);
        
        if(active) {
            for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) {
                if(grid[r][c] === 1) { 
                    ctx.fillStyle='#222'; ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
                    ctx.strokeStyle="#444"; ctx.strokeRect(c*TILE+2, r*TILE+2, TILE-4, TILE-4);
                }
                else if(grid[r][c] === 2 || grid[r][c] === 4) drawBricks(c, r, false);
                else if(grid[r][c] === 3) drawBricks(c, r, true);
            }
            bombs.forEach(b => {
                ctx.fillStyle = player.remote ? "#9b59b6" : "#111";
                ctx.beginPath(); ctx.arc(b.x*TILE+20, b.y*TILE+20, 14, 0, 7); ctx.fill();
                ctx.strokeStyle="#fff"; ctx.lineWidth=2; ctx.stroke();
                if(!player.remote) { b.timer--; if(b.timer <= 0) { explode(b.x, b.y); bombs.splice(bombs.indexOf(b), 1); } }
            });
            explosions.forEach(ex => {
                ctx.fillStyle = ex.dashTrail ? 'rgba(155,89,182,0.6)' : 'rgba(255,200,50,0.8)';
                ctx.fillRect(ex.x*TILE+2, ex.y*TILE+2, TILE-4, TILE-4); ex.life--;
            });
            explosions = explosions.filter(ex => ex.life > 0);
            enemies.forEach(e => {
                drawTacticalHuman(e.x, e.y, "#e74c3c", frame, 0, true, e.isBoss, e.hp, e.trait);
                e.t++; if(e.t > e.speed) {
                    let nx = e.x + e.dx, ny = e.y + e.dy;
                    let canGo = (grid[ny] && grid[ny][nx] === 0);
                    if(e.trait === 'ghost' && grid[ny] && grid[ny][nx] === 2) canGo = true;
                    if(canGo && !bombs.find(b => b.x === nx && b.y === ny)) { e.x = nx; e.y = ny; }
                    else { let d = [[0,1],[0,-1],[1,0],[-1,0]][Math.floor(Math.random()*4)]; e.dx = d[0]; e.dy = d[1]; }
                    e.t = 0;
                }
                if(e.x === player.x && e.y === player.y && player.invuln <= 0) { player.hp--; player.invuln = 60; sfx(40, 'sine', 0.8); }
            });
            drawTacticalHuman(player.x, player.y, player.color, frame, player.invuln, false, false);
            if(player.invuln > 0) player.invuln--;
            if(player.hp <= 0) { active = false; document.getElementById('death-screen').classList.remove('hidden'); }
        }
        
        ctx.setTransform(1,0,0,1,0,0);
        document.getElementById('hp-txt').innerText = Math.max(0, player.hp);
        document.getElementById('gold-txt').innerText = gold;
        document.getElementById('stage-txt').innerText = stage;
        frame++; requestAnimationFrame(loop);
    }
    loop();
</script>
</body>
</html>
