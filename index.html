<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Bomber</title>
    <style>
        body { margin: 0; background: #222; color: white; font-family: sans-serif; overflow: hidden; display: flex; flex-direction: column; align-items: center; }
        canvas { background: #333; box-shadow: 0 0 20px rgba(0,0,0,0.5); touch-action: none; max-width: 100vw; max-height: 70vh; }
        #ui { padding: 10px; text-align: center; }
        .controls { display: grid; grid-template-columns: repeat(3, 60px); grid-gap: 10px; margin-top: 10px; }
        .btn { width: 60px; height: 60px; background: #555; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold; user-select: none; -webkit-tap-highlight-color: transparent; }
        .btn:active { background: #888; }
        #bomb-btn { grid-column: 2; background: #a33; }
    </style>
</head>
<body>

<div id="ui">
    <h2 id="status">Stage 1</h2>
    <div id="stats">Enemies: <span id="enemy-count">0</span></div>
</div>

<canvas id="gameCanvas"></canvas>

<div class="controls">
    <div></div><div class="btn" onclick="move(0,-1)">UP</div><div></div>
    <div class="btn" onclick="move(-1,0)">LEFT</div><div class="btn" id="bomb-btn" onclick="placeBomb()">BOMB</div><div class="btn" onclick="move(1,0)">RIGHT</div>
    <div></div><div class="btn" onclick="move(0,1)">DOWN</div><div></div>
</div>

<script>
/** * GAME CONFIG 
 */
const TILE_SIZE = 40;
const ROWS = 11; // Must be odd
const COLS = 11; // Must be odd
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = COLS * TILE_SIZE;
canvas.height = ROWS * TILE_SIZE;

// Map Legend: 0: Floor, 1: Hard Wall, 2: Breakable, 3: Exit
let grid = [];
let player = { x: 1, y: 1 };
let bombs = [];
let explosions = [];
let enemies = [];
let stage = 1;
let doorRevealed = false;

/**
 * INITIALIZATION
 */
function initLevel() {
    grid = [];
    enemies = [];
    bombs = [];
    explosions = [];
    doorRevealed = false;
    player = { x: 1, y: 1 };

    // 1. Generate Walls
    for (let r = 0; r < ROWS; r++) {
        grid[r] = [];
        for (let c = 0; c < COLS; c++) {
            if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1 || (r % 2 === 0 && c % 2 === 0)) {
                grid[r][c] = 1; // Unbreakable
            } else {
                grid[r][c] = (Math.random() < 0.4 && !(r < 3 && c < 3)) ? 2 : 0; // Random breakable
            }
        }
    }

    // 2. Hide Door under a random breakable block
    let breakables = [];
    for(let r=0; r<ROWS; r++) for(let c=0; c<COLS; c++) if(grid[r][c] === 2) breakables.push({r,c});
    if(breakables.length > 0) {
        let doorLoc = breakables[Math.floor(Math.random() * breakables.length)];
        grid[doorLoc.r][doorLoc.c] = 4; // Special code for "Hidden Door"
    }

    // 3. Spawn Enemies
    let enemyCount = 2 + stage;
    while(enemies.length < enemyCount) {
        let rx = Math.floor(Math.random() * COLS);
        let ry = Math.floor(Math.random() * ROWS);
        if(grid[ry][rx] === 0 && (rx > 4 || ry > 4)) {
            enemies.push({ x: rx, y: ry, dx: Math.random() > 0.5 ? 1 : -1, dy: 0 });
        }
    }
    updateUI();
}

/**
 * CORE LOGIC
 */
function move(dx, dy) {
    let nx = player.x + dx;
    let ny = player.y + dy;
    if (grid[ny][nx] === 0 || grid[ny][nx] === 3) {
        player.x = nx;
        player.y = ny;
        if (grid[ny][nx] === 3) nextStage();
    }
}

function placeBomb() {
    if (bombs.some(b => b.x === player.x && b.y === player.y)) return;
    bombs.push({ x: player.x, y: player.y, timer: 2000 });
}

function explode(bx, by) {
    const directions = [[0,0], [0,1], [0,-1], [1,0], [-1,0]];
    directions.forEach(d => {
        let ex = bx + d[0];
        let ey = by + d[1];
        
        if (grid[ey][ex] === 1) return; // Stop at hard walls
        
        explosions.push({ x: ex, y: ey, timer: 500 });

        // Destroy blocks
        if (grid[ey][ex] === 2) grid[ey][ex] = 0;
        if (grid[ey][ex] === 4) grid[ey][ex] = 3; // Reveal door

        // Kill enemies
        enemies = enemies.filter(e => e.x !== ex || e.y !== ey);
        
        // Kill player
        if (player.x === ex && player.y === ey) gameOver();
    });
}

function update() {
    // Bomb timers
    bombs.forEach((b, i) => {
        b.timer -= 16;
        if (b.timer <= 0) {
            explode(b.x, b.y);
            bombs.splice(i, 1);
        }
    });

    // Explosion timers
    explosions.forEach((e, i) => {
        e.timer -= 16;
        if (e.timer <= 0) explosions.splice(i, 1);
    });

    // Enemy movement (slowed down)
    if (Math.random() < 0.05) {
        enemies.forEach(e => {
            let nx = e.x + e.dx;
            let ny = e.y + e.dy;
            if (grid[ny][nx] === 0) {
                e.x = nx; e.y = ny;
            } else {
                e.dx = Math.random() > 0.5 ? (Math.random() > 0.5 ? 1 : -1) : 0;
                e.dy = e.dx === 0 ? (Math.random() > 0.5 ? 1 : -1) : 0;
            }
            if (e.x === player.x && e.y === player.y) gameOver();
        });
    }
    updateUI();
}

/**
 * DRAWING
 */
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE;
            
            if (grid[r][c] === 1) ctx.fillStyle = '#111';
            else if (grid[r][c] === 2 || grid[r][c] === 4) ctx.fillStyle = '#852';
            else if (grid[r][c] === 3) ctx.fillStyle = '#0f0'; // Door
            else ctx.fillStyle = '#444';
            
            ctx.fillRect(x, y, TILE_SIZE - 1, TILE_SIZE - 1);
        }
    }

    bombs.forEach(b => {
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(b.x * TILE_SIZE + 20, b.y * TILE_SIZE + 20, 15, 0, Math.PI * 2);
        ctx.fill();
    });

    explosions.forEach(e => {
        ctx.fillStyle = 'rgba(255, 100, 0, 0.7)';
        ctx.fillRect(e.x * TILE_SIZE, e.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    });

    enemies.forEach(e => {
        ctx.fillStyle = '#f0f';
        ctx.fillRect(e.x * TILE_SIZE + 5, e.y * TILE_SIZE + 5, 30, 30);
    });

    // Player
    ctx.fillStyle = '#0af';
    ctx.fillRect(player.x * TILE_SIZE + 5, player.y * TILE_SIZE + 5, 30, 30);
}

function updateUI() {
    document.getElementById('enemy-count').innerText = enemies.length;
    document.getElementById('status').innerText = `Stage ${stage} ${enemies.length === 0 ? '- Find the Exit!' : ''}`;
}

function nextStage() {
    if (enemies.length > 0) return;
    stage++;
    initLevel();
}

function gameOver() {
    alert("Game Over! Restarting...");
    stage = 1;
    initLevel();
}

// Game Loop
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Controls
window.addEventListener('keydown', e => {
    if (e.key === 'ArrowUp') move(0, -1);
    if (e.key === 'ArrowDown') move(0, 1);
    if (e.key === 'ArrowLeft') move(-1, 0);
    if (e.key === 'ArrowRight') move(1, 0);
    if (e.key === ' ') placeBomb();
});

initLevel();
loop();
</script>
</body>
</html>
